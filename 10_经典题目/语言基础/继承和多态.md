**派生类怎么初始化从基类继承来的成员变量?**

* 派生类从基类可以继承来所有的成员,除了构造函数和析构函数
* 通过调用基类相应的构造函数来初始化
* 派生类的构造函数和析构函数负责初始化和清理派生类部分,派生类从基类继承来的成员的初始化和清理由基类的构造和析构来负责

**派生类对象构造和析构的过程:**

* 派生类调用基类的构造函数,初始化从基类继承来的成员
* 调用派生类自己的构造函数,初始化派生类自己特有的成员
* 调用派生类的析构函数释放派生类成员可能占用的外部资源
* 调用基类的析构函数释放派生类内存中从基类继承来的成员可能占用的外部资源

**重载,隐藏,覆盖:**

* 重载关系
  * 一组函数要重载,必须处在同一个作用域中,且函数名字相同,参数列表不同
* 隐藏关系(作用域的隐藏)
  * 在继承结构中,派生类的同名成员把基类的同名成员给隐藏调用了
* 覆盖关系
  * 基类和派生类的方法,返回值,函数名以及参数列表都相同且基类的方法是虚函数,那么派生类的方法会自动处理成虚函数

**基类对象与派生类对象的转换:**

* 基类对象=派生类对象   类型可以从下到上的转换
* 派生类对象!=基类对象   类型不能从上到下的转换
* 基类指针(引用)=派生类对象地址  类型可以从下到上的转换
* 派生类指针(引用)!=基类对象地址  类型不能从上到下的转换
* 总结:在继承结构中进行上下的类型转换,默认只支持从下到上的类型的转换

**静态绑定和动态绑定:**

**虚函数对基类的影响:**

* 一个类里面定义了虚函数,那么编译阶段,编译器会给这个类类型产生一个唯一的`vftable`虚函数表,虚函数表中主要存储的内容就是`RTTI`指针和虚函数的地址.当程序运行时,每一张虚函数表都会加载到内存的`.rodata`区(`RTTI run-time type information,`指向此类型的类型字符串)
* 一个类里面定义了虚函数,那么这个类定义的对象在运行时内存中会多存储一个`vfptr`虚函数指针,指向相应类型的虚函数表.一个类型定义n个对象,它们的`vfptr`指向的都是同一张虚函数表
* 一个类里面虚函数的个数,不影响对象内存大小,影响虚函数表的大小

**基类虚函数对派生类的影响:**

* 如果派生类中的方法和基类继承来的某个虚函数返回值,函数名,参数列表都相同,那么派生类的这个方法自动处理成虚函数(重写覆盖) 

**哪些函数不能实现成虚函数?**

* 构造函数
  * 虚函数能产生地址存储在虚函数表中且对象必须存在
  * 构造函数构造完成对象才能存在,构造函数中调用的任何函数都是静态绑定
* static静态成员方法不依赖对象

**虚析构函数:**

* 析构函数调用时对象是存在的,所以可以定义为虚函数
* 基类的析构函数是虚函数,派生类析构函数自动成为虚函数
* 基类的指针(引用)指向堆上new出来的派生类对象时,当调用析构函数时,必须发生动态绑定,否则会导致派生类的析构函数无法调用

**虚函数的调用一定是动态绑定?**

* 在类的构造函数中调用虚函数是静态绑定
* 用对象本身调用虚函数是静态绑定
* 由指针(引用)调用虚函数是动态绑定 

**如何解释多态?**

* 静态多态(编译时期):函数重载,模板
* 动态多态(运行时期):
  * 在继承结构中,基类指针(引用)指向派生类对象,通过指针(引用)调用同名覆盖方法(虚函数)基类指针指向哪个派生类对象就会调用哪个派生类对象的同名覆盖方法,称为多态,底层是通过动态绑定实现的

**继承的好处:**

* 代码的复用
* 在基类中提供统一的虚函数接口,派生类重写虚函数,然后就能使用多态了

**抽象类和普通类有什么区别?**

*  抽象类不能抽象某个实体的类型,而是让派生类复用其属性,给所有的派生类保留统一的覆盖/重写接口
* 抽象类不能再实例化对象,但是可以定义指针和引用变量

 **虚继承:**

* 被虚继承的类称为虚基类.此时派生类内存中继承的内容会移到最后,取而代之的是一个`vbptr`指针,指向一个`vbtable`

**菱形继承问题?**

* 多重继承的好处:更多的代码复用
* 但是派生类有多份间接基类的数据,解决方案为将总基类虚继承

**C++语言级别提供的四种类型转换方式:**

* `const_cast<>`:去掉(指针或引用)常量属性的类型转换
* `static_cast<>`:提供编译器认为安全的类型转换(没有任何联系的类型之间的转换就被否定了)
* `reinterpret_cast<>`:类似于C风格的强制类型转换
* `dynamic_cast<>`:主要用在继承结构中可以支持`RTTI`类型识别的上下转换