# 语言基础

## this指针是干什么的?

一个类型有很多对象,每个对象都有各自的成员变量,但它们共享一套成员方法,成员方法被编译器编译后参数列表都会多出一个this指针,通过this指针就可以区分这个成员方法正在操作的哪个对象的成员.

## new[]和delete能否混用?

new和delete本质上是运算符重载,delete先要调用析构函数然后释放内存,如果是自定义类型而且提供了析构函数,那么new[]一定要匹配delete[],`test *ptr=new test[10]`在开辟内存时除了会开辟10个test对象的内存,还会多开辟一个4字节的内存用来记录对象的个数,但`ptr`指针指向的是第一个test对象的地址,这就必须`delete[]ptr`告诉编译器释放数组,需要从`ptr-4`的地址开始释放内存.对于普通的编译器内置类型,则可以混用,但应该尽量匹配.

## static关键字的作用?

面向过程:static可以修饰全局变量、函数、局部变量，全局变量和函数被static修饰后，在符号表中，符号的作用域就从`g`变成`l`，如果修饰局部变量，则变量的内存放到`.data`或`.bss`(局部变量本身不产生符号,但被static修饰后则会产生符号且为`l`)

面向对象:static可以修饰成员变量(对象私有变成对象共享),成员方法(不再产生this指针).

## 继承的好处?

* 代码的复用
* 通过继承在基类里面给所有的派生类保留统一的纯虚函数接口,等待派生类进行重写,通过使用多态,可以通过基类的指针访问不同派生类对象的同名覆盖方法

## 多态是什么?

同一操作作用于不同的对象可以有不同的理解,产生不同的执行结果

多态分为静态多态和动态多态,静态多态是编译时期多态,动态多态是运行时期多态

静多态:函数重载和模板    动多态:虚函数

## 空间配置器的作用?

allocator:给容器使用,主要作用是把对象的内存开辟和对象构造分开,把对象析构和内存释放分开

初始化容器只需要给容器开辟空间(`malloc`),并不需要给空间构造对象,当从容器中删除对象时,要将对象析构而不需要释放内存

当容器出作用域时,只需要析构有效的对象再释放内存

## vector和list的区别?

数组和链表的区别

vector动态数组,适合随机访问,list为双向循环链表,适合增加删除

## map和多重map?

map:映射表[key-value],底层实现为红黑树,不允许key重复,`multimap`允许key重复

红黑树:

## 如何防止内存泄漏?智能指针详述?

内存泄漏:分配的堆内存没有释放,防止内存泄漏方法:智能指针(利用对象自动析构)

## C++如何调用C语言?

C和C++生成符号方式不同,C和C++语言之间的`API`接口是无法直接调用的,C语言的函数声明必须扩在`extern "C"{}`中

## C++什么时候出现访问越界?

* 数组元素访问越界
* 字符串处理没有添加'\0'字符
* 使用类型强转,让一个大类型的指针指向一个小内存,解引用指针

## C和C++的区别?内存分布有什么区别?

* 引用,函数重载,类和对象,动态内存分配,const,inline,模板,STL,异常,智能指针,运算符重载
* 内存分布基本没有什么区别

## malloc和new的区别?

* malloc按字节开辟内存,new底层也是通过malloc开辟内存,但是还可以提供初始化
* malloc开辟内存失败会返回nullptr,new开辟失败抛出bad_alloc类型的异常
* malloc是C的库函数,new是operator new运算符
* malloc开辟单个和数组的方式一样,new不一样

## map和set容器的实现原理?

set集合,只存储key,map映射表,存储[key,value]键值对,底层结构都是红黑树

## shared_ptr引用计数存放在哪里?

堆上分配的

## STL迭代器失效问题?

迭代器是不允许一边读一边修改的,当通过迭代器插入一个元素使用迭代器就都失效了,当通过迭代器删除一个元素,当前删除位置到后面所有元素的迭代器都失效

当通过迭代器更新容器元素以后,要及时对迭代器进行更新,insert/erase方法都会返回新位置的迭代器

## struct和class的区别?

* 定义类的时候的区别,struct默认是公有,class默认是私有
* 继承时,class B:A为私有继承,struct B:A为共有继承
* class还可以定义模板类型参数

## vector和数组的区别?

vector是数组面向对象的表示,可以自动扩容,不用担心越界

## 编译链接全过程?

预编译,编译,汇编=>二进制可重定向obj文件*.o

链接:合并段,符号解析   符号的重定向=>可执行文件

## 初始化全局变量和未初始化全局变量有什么区别?

.data初始化且初始值不为0,  .bss未初始化或初始化为0的

## 堆和栈的区别?

堆内存的大小远大于栈内存,堆是通过malloc/new开辟,手动free/delete

函数的运行需要在栈上分配栈帧,函数的局部变量在栈上定义,不需要手动回收

堆的分配由低地址到高地址

栈的分配由高地址到低地址

## 构造函数和析构函数可不可以是虚函数?

构造函数不可以是虚函数

析构函数可以是虚函数

虚函数需要将函数地址放入虚函数表内,虚函数表由虚函数指针指向,而虚函数指针在对象里

## 构造函数和析构函数中能不能抛出异常?

构造函数不能抛出异常,对象创建失败,编译器就不会调用对象的析构函数了,资源泄漏

析构函数也不能抛异常,只能在析构函数的最后一行抛异常,否则有代码无法执行,资源泄漏

## 宏和内联的区别?

`#define`是预处理阶段处理,字符串替换,可以定义常量,代码块,函数块

`inline`是编译阶段,函数调用点通过函数的实参把函数代码直接展开调用,节省了函数的调用开销

宏没办法调试,内联函数可以调试(debug版本下`inline`和普通函数一样,有标准的函数调用过程)

## 局部变量存在哪里?

局部变量存在stack上,通过ebp指针偏移来访问的

局部变量不产生符号,属于指令的一部分

## 拷贝构造函数为什么传引用而不传值?

传值的话形参需要调用拷贝构造函数,产生编译错误

## 内联函数和普通函数的区别?

函数的调用开销

开辟:push ebp -->mov ebp,esp-->sub esp,4Ch-->rep stos 0xCCCCCCCC

(windows下栈初始化,GCC:分配完栈中不做任何栈初始化)

释放:mov esp,ebp-->pop ebp-->ret

## 如何实现一个不可以被继承的类?

派生类初始化过程是基类构造然后派生类构造

把基类的构造函数私有化

## 什么是纯虚函数?虚函数表放在哪里?

`virtual void func()=0;`有纯虚函数的类叫作抽象类,不能实例化对象,但可以定义指针和引用

一般定义在基类里面,基类不代表任何实体,它的主要作用是给所有派生类指针保留统一的纯虚函数接口,让派生类进行重写,方便使用多态机制,因为基类不需要实例化,它的方法也就不知道该怎么实现,只有派生类知道如何实现

虚函数表在编译阶段产生的,虚函数表运行时加载到`.rodata`段

## const和static的区别?

const定义的叫常量,编译过程中,把出现常量名字的地方,用常量的值进行替换

const还可以定义常成员方法,test *this--->const test *this,普通方法和常对象都可以调用

面向过程:

const:全局变量,局部变量,形参变量,不可以修饰函数

static:全局变量,局部变量,函数

面向对象:

const:常方法,常成员变量,依赖对象

static:静态方法,静态成员变量,this指针没有了,不依赖对象