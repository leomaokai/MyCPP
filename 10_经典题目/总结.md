# 语言基础

## this指针是干什么的?

一个类型有很多对象,每个对象都有各自的成员变量,但它们共享一套成员方法,成员方法被编译器编译后参数列表都会多出一个this指针,通过this指针就可以区分这个成员方法正在操作的哪个对象的成员.

## new[]和delete能否混用?

new和delete本质上是运算符重载,delete先要调用析构函数然后释放内存,如果是自定义类型而且提供了析构函数,那么new[]一定要匹配delete[],`test *ptr=new test[10]`在开辟内存时除了会开辟10个test对象的内存,还会多开辟一个4字节的内存用来记录对象的个数,但`ptr`指针指向的是第一个test对象的地址,这就必须`delete[]ptr`告诉编译器释放数组,需要从`ptr-4`的地址开始释放内存.对于普通的编译器内置类型,则可以混用,但应该尽量匹配.

## static关键字的作用?

面向过程:static可以修饰全局变量、函数、局部变量，全局变量和函数被static修饰后，在符号表中，符号的作用域就从`g`变成`l`，如果修饰局部变量，则变量的内存放到`.data`或`.bss`(局部变量本身不产生符号,但被static修饰后则会产生符号且为`l`)

面向对象:static可以修饰成员变量(对象私有变成对象共享),成员方法(不再产生this指针).

## 继承的好处?

* 代码的复用
* 通过继承在基类里面给所有的派生类保留统一的纯虚函数接口,等待派生类进行重写,通过使用多态,可以通过基类的指针访问不同派生类对象的同名覆盖方法

## 多态是什么?

多态分为静态多态和动态多态,静态多态是编译时期多态,动态多态是运行时期多态

静多态:函数重载和模板    动多态:虚函数

## 空间配置器的作用?

allocator:给容器使用,主要作用是把对象的内存开辟和对象构造分开,把对象析构和内存释放分开

初始化容器只需要给容器开辟空间(`malloc`),并不需要给空间构造对象,当从容器中删除对象时,要将对象析构而不需要释放内存

当容器出作用域时,只需要析构有效的对象再释放内存

## vector和list的区别?

数组和链表的区别

vector动态数组,适合随机访问,list为双向循环链表,适合增加删除

## map和多重map?

map:映射表[key-value],底层实现为红黑树,不允许key重复,`multimap`允许key重复

红黑树:

## 如何防止内存泄漏?智能指针详述?

内存泄漏:分配的堆内存没有释放,防止内存泄漏方法:智能指针(利用对象自动析构)