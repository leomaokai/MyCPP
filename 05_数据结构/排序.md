# 插入排序

* 设待排序的序列存储在数字`r[n]`中,首先将`r[1]`看成一个有序序列,将`r[0]`看成暂存元素空间
* 依次将后面的元素插入到已经排好的序列中,并保持有序性

复杂度: 最好情况`O(n)`,最坏情况`O(n^2)`

稳定性: 稳定

```cpp
void insertsort(int r[],int n)
{
    int i,j;
    for(i=2;i<=n;++i)
    {
        if(r[i]<r[i-1])	//将r[i]与前一个元素比较
        {
            r[0]=r[i];	//将r[i]暂存到r[0]
            r[i]=r[i-1];//将r[i-1]后移
            for(j=i-2;r[j]>r[0];--j)//从后向前寻找插入位置
                r[j+1]=r[j];//将大于r[0]的元素逐个后移
            r[j+1]=r[0];	//将r[0]插入到r[j+1]位置
        }
    }
}
```

# 冒泡排序

两两比较,逆序交换

复杂度: 最好情况`O(n)` 最坏情况`O(n^2)`

稳定性: 稳定

```cpp
void bubblesort(int r[],int n)
{
    int i,j,temp;
    bool flag=true;
    i=n-1;
    while(i>0 && flag)
    {
        flag=false;
        for(j=0;j<i;++j)
        {
            if(r[j]>r[j+1])
            {
                flag=true;
                temp=r[j];
                r[j]=r[j+1];
                r[j+1]=temp;
            }
        }
        --i;
    }
}
```

# 快速排序

快速排序的基本思想是基于分治策略

* 分解:先从数列中取出一个元素作为基准元素,以基准元素为标准,将问题分解为两个子序列,使小于或等于基准元素的子序列在左侧,大于基准元素的子序列在右侧
* 治理:对两个子序列进行快速排序
* 合并:将排好序的两个子序列合并在一起

复杂度:

* 如果基准元素选取不当,有可能分解成规模为`0`和`n-1`的两个子序列,这样快速排序就退化为冒泡排序
* 平均复杂度`O(nlogn)`
* 使用递归树,空间复杂度平均`O(logn)`,最坏`O(n)`

基准元素选取方法:

* 取第一个或最后一个或中间位置
* 取第一个最后一个中间元素三者的中位数
* 取随机数

算法步骤:

* 取数组第一个元素作为基准元素,`pivot=R[low]`,定义两个指针指向两端,`i=low`,`j=high`
* 从右向左扫描,找小于等于`pivot`的数,如果找到,交换`R[i]`和`R[j]`,`i++`
* 从左向右扫描,找大于`pivot`的数,如果找到,交换`R[i]`和`R[j]`,`j--`
* 重复前两步,知道`i`和`j`重合,返回该位置`mid=i`,该位置的数正好是`pivot`元素
* 以`mid`为界,将元数据分为两个子序列,左侧子序列元素都比`pivot`小,右侧子序列元素都比`pivot`大,然后分别对这两个子序列进行快速排序

[快速排序代码示例](code/sort01.cpp)

# 归并排序

归并排序就是采用分治的策略

* 分解:将待排序元素分成大小大致相同的两个子序列
* 自理:对两个子序列进行归并排序
* 合并:将排好序的子序列进行合并

复杂度:

* 每次从序列中间开始归并排序,无最好和最坏之分
* 合并算法可以在`O(n)`时间内完成
* 总时间复杂度`O(nlogn)`
* 需要一个辅助数组,空间复杂度`O(n)`

[归并排序代码示例](code/sort02.cpp)

# 总结

| 排序算法 | 平均时间复杂度 |   最好情况    |   最坏情况    | 空间复杂度 | 排序方式  | 稳定性 |
| -------- | :------------: | :-----------: | :-----------: | :--------: | :-------: | :----: |
| 冒泡排序 |    O(n^2^)     |     O(n)      |    O(n^2^)    |    O(1)    | in-place  |  稳定  |
| 选择排序 |    O(n^2^)     |    O(n^2^)    |    O(n^2^)    |    O(1)    | in-place  | 不稳定 |
| 插入排序 |    O(n^2^)     |     O(n)      |    O(n^2^)    |    O(1)    | in-place  |  稳定  |
| 希尔排序 |   O(n log n)   | O(n log^2^ n) | O(n log^2^ n) |    O(1)    | in-place  | 不稳定 |
| 归并排序 |   O(n log n)   |  O(n log n)   |  O(n log n)   |    O(n)    | out-place |  稳定  |
| 快速排序 |   O(n log n)   |  O(n log n)   |    O(n^2^)    |  O(log n)  | in-place  | 不稳定 |
| 堆排序   |   O(n log n)   |  O(n log n)   |  O(n log n)   |    O(1)    | in-place  | 不稳定 |
| 计数排序 |     O(n+k)     |    O(n+k)     |    O(n+k)     |    O(k)    | out-place |  稳定  |
| 桶排序   |     O(n+k)     |    O(n+k)     |    O(n^2^)    |   O(n+k)   | out-place |  稳定  |
| 基数排序 |     O(n*k)     |    O(n*k)     |    O(n*k)     |   O(n+k)   | out-place |  稳定  |



