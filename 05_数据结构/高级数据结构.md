# 并查集

并查集是一种树形数据结构,用于处理一些不相交集合的合并及查询问题

将两个祖宗不同的结点合并为同一树(只修改两祖宗的集合号一致)

判断两个结点是否有亲戚关系:先分别寻找其祖宗,将寻找路径上的结点的集合号与祖宗修改一致,若两祖宗的集合号一样,则为亲戚关系,否则不是

![](img\more02.png)

[并查集代码](more/more01.cpp)

[使用并查集的kurskal](code/graph08.cpp)

# 优先级队列

优先级队列是利用堆来实现大的,堆可以看作一棵完全二叉树的顺序存储结构,在这颗完全二叉树中,如果每一个结点的值都大于等于左右孩子的值,称为最大堆,如果每个结点的值都小于等于左右孩子的值,称为最小堆

使用优先级队列寻找最值则只需要O(logn)的时间

优先级队列使用顺序数组存储,因为完全二叉树的结点规律,编号为`i`的结点的左孩子为`2i`,右孩子为`2i+1`,父亲为`i/2`,具有`n`个结点的完全二叉树的深度为`logn + 1`

出队:堆顶出队,最后一个结点代替堆顶的位置,重新调整为堆(下沉)`O(logn)`

下沉:堆顶与左右孩子比较,如果比孩子大,则已调整为堆,如果比孩子小,则与较大的孩子交换,交换到新的位置后,继续向下比较,从根结点一直比较到叶子

入队:将新结点放入最后一个结点的之后,重新调整为堆(上浮)`O(logn)`

上浮:新结点入队,判断与父亲结点的大小,若比父亲小,则已调整为堆,如果比父亲大,则与父亲结点交换继续向上比较,从叶子一直比较到根

创建堆:按顺序存储,从`n/2`结点开始执行下沉操作

[优先级队列代码](more/more02.cpp)

# 树状数组

 树状数组,可以高校地计算数列前缀和.它地查询和更新都可以在`O(logn)`时间完成

树状数组引入了分级管理制度,设置一个管理小组`c[i]`,管理小组的每个成员管理一个或多个连续的元素,通过二进制分解划分区间

![](img\more01.png)

二进制分解:求得`i`的二进制,若二进制数后面有k个连续0,则`c[i]`管理2^k^个数,从`a[i]`向前的2^k^个数.如6的二进制`110`,如何得到`010`,先对`110`取反`001`再加`010`,再和原数`110`求与运算即可得到`010`

```cpp
int lowbit(int i)
{
    return (-i)&i;
}
```

前驱和后继:

* 直接前驱:`c[i]`的直接前驱为`c[i-lowbit(i)]`,即`c[i]`左侧紧邻的子树的根
* 直接后继:`c[i]`的直接后继为`c[i+lowbit(i)]`,即`c[i]`的父亲

树状数组下标从1开始,不能从0开始,因为`lowbit(0)=0`,会出现死循环

[树状数组代码](more/more03.cpp)

# 线段树

线段树是一种二叉搜索树,也是平衡二叉树,它的每个结点对应一个区间`[L,R]`,叶子结点对应的区间只有一个结点`(L=R)`.每个非叶子结点`[L,R]`,其左孩子区间为`[L,(L+R)/2]`,右孩子区间为`[(L+R)/2+1,R]`

![](img\more03.png)

线段树主要用于更新和查询,一般至少有一个区间更新或查询`O(logn)`,底层是顺序数组

创建线段树:

* 如果是叶子结点,则结点的最值就是对应位置的元素值
* 如果是非叶子结点,递归创建左子树和右子树
* 结点区间的最值等于该结点左右子树最值的最大值

线段树的点更新,区间查询与创建类似 

[线段树代码1](more/more04.cpp)

区间更新:

* 如果结点的区间被查询区间`[l,r]`覆盖,仅对该结点进行更新,并做懒标记,表示该结点被更新过,对该结点的子结点不再进行更新
* 在查询过程中,若当前结点带有懒标记,懒标记传给子结点,继续查询
* 更新最值

[线段树代码02](more/more05.cpp)

# ST表

倍增:如果问题的状态空间特别大,一步一步的递推算法复杂度太高,可以通过倍增思想,只考虑2的整数次幂位置,快速缩小求解范围,直到找到所要的解

ST表称为稀疏表,采用倍增的思想,在`O(nlogn)`的时间构造一个二维表之后,可以在`O(1)`的时间内查询区间`[l,r]`的最值.ST算法可以有效的解决在线RMQ问题(区间最值问题)

用`F[i,j]`表示区间`[i,i+2^j^-1]`的最值,区间的长度为2^j^,`i`表示开始下标,`j`表示区间长度2^j^

根据倍增思想,区间长度为2^j^可以分成两个区间长度为2^j-1^的子区间,然后求两个子区间的最值即可

递推公式:`F[i,j]=max(F[i,j-1] , F[ i+2^j-1^ , j-1 ])`

数组长度为`n`,则最大区间长度为2^k^,k=logn

如:`F[i][0]`为10个元素,log10为3,`F[2][3]`表示区间`[2,9]`之间的最大值12

<img src="img\more05.png" style="zoom: 50%;" />

RMQ问题有多种解决方法:

* 线段树预处理`O(nlogn)`,查询`O(logn)`,支持在线修改
* ST表预处理`O(nlogn)`,查询`O(1)`,但不支持在线修改

[ST表代码](more/more06.cpp)

# LCA

最近公共祖先(LCA),是指在有根树中,某两个结点`u`和`v`最近的公共祖先

利用LCA求解树上任意两个点之间的距离,`dist[i]`表示`i`结点到树根的距离,则`u`和`v`两个结点的距离为`dist[u]+dist[v]-2*dist[lca]`

暴力搜索法:

* 向上标记法,从`u`向上一直到根结点,标记所有经过的结点,如果`v`被标记,则`v`结点即为`LCA(u,v)`,否则,`v`也向上走,遇到第一个已被标记的结点即为`LCA(u,v)`
* 同步前进法,将`u`,`v`中深度较深的那个结点向上走到和深度较浅的结点同一深度,然后两个点一起向上走,直到走到同一个结点,则该结点为`LCA(u,v)`

树上倍增法:

`F[i][j]`表示`i`的`2^j`辈祖先,`F[i][j]`可以分成长度为`j-1`的两部分

递推公式:`F[i][j] = F[ F[i][j-1] ][j-1]`

[树上倍增法代码](more/more07.cpp)

