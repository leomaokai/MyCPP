#  字符串

字符串存储:

* 顺序存储:连续的空间存储字符串
  * 以`'\0'`表示字符串结束,`'\0'`不算在字符串长度内
  * 在`0`空间存储字符串的长度
  * 结构体存储字符串
* 链式存储
  * 一般很少用,单链比较占空间,块链增删需要块间移动

[字符串类代码](code/code05.cpp)

# BF算法

```cpp
while(i<=slien && j<=tlen)
{
    sum++;
    if(s[i-1]==t[j-1])//如果相同,比较下一个
    {
        i++;
        j++;
    }
    else
    {
        i=i-j+2;//i退回上一轮开始比较主串的下一个字符
        j=1;	//j退回1
    }
}
//最好情况O(n+m),最坏情况O(nm)
```

[BF算法](code/code06.cpp)

# KMP算法

`i`不回退

`j`回退位置是`KMP`算法的关键

`j`表示T串字符的位置,`next[j]`表示j位置字符与S串不等时,`j`回退的位置

* 若`j=1`,则`next[j]=0`
* 若T`(j位置前的部分)`相等前缀和后缀的最大长度为`l`,则`next[j]=l+1`
* 若T没有相等的前缀和后缀,则`next[j]=1`

```cpp
void get_next(string t)
{
    int j=1,k=0;
    next[1]=0;
    while(j<t.length())
    {
        if(k==0 || t[k-1]==t[j-1])//前缀和后缀比较
            next[++j]=++k;
        else
        	k=next[k];//否则回退到k位置,动态规划的思想
    }
}
while(i<=slen && j<=tlen)
{
    sum++;
    if(s[i-1]==t[j-1])
    {
        ++i;
        ++j;
    }
    else
        j=next[j];
}
//时间复杂度O(n+m)
```

一般情况下,BF算法的时间复杂度最好情况也是`O(n+m)`,只有在主串和字串有很多部分匹配的情况下,`KMP`算法才显得更优势

[KMP算法](code/code07.cpp)