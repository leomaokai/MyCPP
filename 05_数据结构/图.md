稀疏图采用邻接表存储,稠密图采用邻接矩阵存储

# 图的存储

## 连接矩阵

数据结构:

* 一维数组存储顶点
* 二维数组存储顶点间边的关系

优点:

* 快速判断两点之间是否有边
* 方便计算各顶点的度(`O(n)`)

缺点:

* 不便于增删顶点
* 不便于访问所有邻接点
* 空间复杂度高(`O(n^2)`)

[连接矩阵](code/graph01.cpp)

## 邻接表

数据结构

* 顶点结点:包括顶点信息和指向第一个邻接点的指针,可用一维数组存储
* 邻接点结点:包括邻接点的存储下标和指向下一个邻接点的指针,顶点v的所有邻接构成一个单链表

优点:

* 便于增删顶点
* 便于访问所有邻接点(`O(n+e)`)
* 空间复杂度低(`O(n+e)`)

缺点:

* 不便于判断两顶点之间是否有边,要判断两顶点是否右边,需要遍历该顶点后面的邻接点链表
* 不便于计算各顶点的度,无向邻接表中,顶点的度为该顶点后面单链表的结点个数;有向图中单链表结点个数为出度,入度需要遍历整个邻接表;逆邻接表(所有弧的箭头反向)易求入度,不易求出度

[邻接表](code/graph02.cpp)

## 链式前向星

**静态链表存储**,用边集数组和邻接表结合,可用快速访问一个顶点的所有邻接点

数据结构:

* 边集数组:`edge[]`,`edge[i]`表示第`i`条边
* 头节点数组:`head[]`,`head[i]`存`i`为顶点的第一条边的下标

[链式前向星](code/graph03.cpp)

# 图的搜索

## 深度优先搜索

后被访问的顶点,其邻接点先被访问(栈和递归)

算法步骤:

* 初始化图中所有顶点未被访问
* 从图中某个顶点v出发,访问v并标记已访问
* 依次检查v的邻接点w,如果w未被访问,则从w出发进行深度优先遍历(递归)

深度优先搜索走过的路径为深度优先生成树(连通m=n-1)

```cpp
//基于连接矩阵的深度优先遍历
void DFSAM(graph &g,int v)
{
    cout<<g.vex[v]<<" ";//访问v
    visited[v]=1;
    for(int w=0;w<g.vexnum;++w)//依次检查v的所有邻接点
    {
        if(g.edge[v][w] && !visited[w])//w与v邻接且未被访问
            DFSAM(g,w);//递归从w顶点开始深度优先遍历
    }
}
/*
查找每个顶点的邻接点需要O(n)时间,一共n个顶点,总时间复杂度为O(n^2)
使用一个递归工作栈,空间复杂度为O(n),栈的高度为生成树的深度
*/
```

```cpp
//基于邻接表的深度优先遍历
void DFSAL(graph &g,int v)
{
    cout<<g.vex[v].data<<" ";//访问v
    visited[v]=1;
    listnode *p=g.vex[v].first;//定义一个指向第一个邻接点的指针
    while(p!=nullptr)
    {
        int w=p->v;
        if(!visited[w])
            DFSAL(g,w);//递归从w开始深度优先遍历
        p=p->next;//指针移动
    }
}
/*
查找邻接点的时间复杂度为O(e),初始化时间O(n),总时间复杂度O(n+e)
使用一个递归工作栈,空间复杂度O(n)
*/
```

```cpp
//非连通图需要查漏补缺,次函数与上述两个函数形成函数重载
void DFS(graph &g)
{
    for(int i=0;i<g.vexnum;++i)
    {
        if(!visited[i])
            DFS(g,i);
    }
}
```



## 广度优先搜索

从某个顶点出发,一次性访问所有未被访问的邻接点,再依次从这些访问过的邻接点出发(队列)

算法步骤:

* 初始化图中所有顶点未被访问,初始化一个空队列
* 从图中的某个顶点v出发,访问v并标记已访问,将v入队
* 如果队列非空,则继续执行,否则算法结束
* 队头元素v出队,依次访问v的所有未被访问的邻接点,标记已访问并入队,转向第三步

广度优先搜索走过的路径为广度优先生成树

```cpp
//基于邻接矩阵的广度优先遍历
//#include<queue>
void BFSAM(graph &g,int v)
{
    queue<int> que;		//创建一个队列
    cout<<g.vex[v]<<" ";//访问v
    visited[v]=1;		//标记已访问
    que.push(v);		//入队
    while(!que.empty())	//判断队列是否为空
    {
        int u,w;		//u为队头顶点
        u=que.front();
        que.pop();		//出队,判断队头顶点邻接点
        for(w=0;w<g.vexnum;++w)
        {
            if(g.edge[u][w] && !visited[w])//u与w邻接且w未访问
            {
                cout<<g.vex[w]<<" ";	//访问w
                visited[w]=1;		//标记已访问
                que.push(w);		//入队
            }
        }
    }
}
/*
查找每个邻接点需要O(n)时间,一共n个顶点,总时间复杂度O(n)
使用一共辅助队列,最坏情况下每个顶点入队一次,空间复杂度O(n)
*/
```

```cpp
//基于邻接表的广度优先遍历
void BFSAL(graph &g,int v)
{
    queue<int> que;			//创建一个队列
    cout<<g.vex[v].data<<" ";//访问v
    visited[v]=1;	//标记已访问
    que.push(v);	//入队
    while(!que.empty())//判断队列是否为空
    {
        int u=que.front();
        que.pop();//出队
        listnode *p=g.vex[u].first;//p指向u顶点的第一个邻接点
        while(p!=nullptr)
        {
            int w=p->v;
            if(!visited[w])
            {
                cout<<g.vex[w].data<<" ";
                visited[w]=1;//标记
                que.push(w);//入队
            }
            p=p->next;
        }
    }
}
/*
查找邻接点的时间复杂度为O(e),初始化时间O(n),总时间复杂度O(n+e)
使用一个辅助队列,最坏情况每个顶点入队一次,空间复杂度O(n)
*/
```

```cpp
//非连通图
void BFS(graph &g)
{
    for(int i=0;i<g.vexnum;++i)
    {
        if(!visited[i])
            BFS(g,i);
    }
}
```



# 图的连通性