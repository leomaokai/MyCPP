# 图的存储

稀疏图采用邻接表存储,稠密图采用邻接矩阵存储

## 连接矩阵

数据结构:

* 一维数组存储顶点
* 二维数组存储顶点间边的关系

优点:

* 快速判断两点之间是否有边
* 方便计算各顶点的度(`O(n)`)

缺点:

* 不便于增删顶点
* 不便于访问所有邻接点
* 空间复杂度高(`O(n^2)`)

[连接矩阵](code/graph01.cpp)

## 邻接表

数据结构

* 顶点结点:包括顶点信息和指向第一个邻接点的指针,可用一维数组存储
* 邻接点结点:包括邻接点的存储下标和指向下一个邻接点的指针,顶点v的所有邻接构成一个单链表

优点:

* 便于增删顶点
* 便于访问所有邻接点(`O(n+e)`)
* 空间复杂度低(`O(n+e)`)

缺点:

* 不便于判断两顶点之间是否有边,要判断两顶点是否右边,需要遍历该顶点后面的邻接点链表
* 不便于计算各顶点的度,无向邻接表中,顶点的度为该顶点后面单链表的结点个数;有向图中单链表结点个数为出度,入度需要遍历整个邻接表;逆邻接表(所有弧的箭头反向)易求入度,不易求出度

[邻接表](code/graph02.cpp)

## 链式前向星

**静态链表存储**,用边集数组和邻接表结合,可用快速访问一个顶点的所有邻接点

数据结构:

* 边集数组:`edge[]`,`edge[i]`表示第`i`条边
* 头节点数组:`head[]`,`head[i]`存`i`为顶点的第一条边的下标

[链式前向星](code/graph03.cpp)

# 图的搜索

## 深度优先搜索

后被访问的顶点,其邻接点先被访问(栈和递归)

算法步骤:

* 初始化图中所有顶点未被访问
* 从图中某个顶点v出发,访问v并标记已访问
* 依次检查v的邻接点w,如果w未被访问,则从w出发进行深度优先遍历(递归)

深度优先搜索走过的路径为深度优先生成树(连通m=n-1)

```cpp
//基于连接矩阵的深度优先遍历
void DFSAM(graph &g,int v)
{
    cout<<g.vex[v]<<" ";//访问v
    visited[v]=1;
    for(int w=0;w<g.vexnum;++w)//依次检查v的所有邻接点
    {
        if(g.edge[v][w] && !visited[w])//w与v邻接且未被访问
            DFSAM(g,w);//递归从w顶点开始深度优先遍历
    }
}
/*
查找每个顶点的邻接点需要O(n)时间,一共n个顶点,总时间复杂度为O(n^2)
使用一个递归工作栈,空间复杂度为O(n),栈的高度为生成树的深度
*/
```

```cpp
//基于邻接表的深度优先遍历
void DFSAL(graph &g,int v)
{
    cout<<g.vex[v].data<<" ";//访问v
    visited[v]=1;
    listnode *p=g.vex[v].first;//定义一个指向第一个邻接点的指针
    while(p!=nullptr)
    {
        int w=p->v;
        if(!visited[w])
            DFSAL(g,w);//递归从w开始深度优先遍历
        p=p->next;//指针移动
    }
}
/*
查找邻接点的时间复杂度为O(e),初始化时间O(n),总时间复杂度O(n+e)
使用一个递归工作栈,空间复杂度O(n)
*/
```

```cpp
//非连通图需要查漏补缺,次函数与上述两个函数形成函数重载
void DFS(graph &g)
{
    for(int i=0;i<g.vexnum;++i)
    {
        if(!visited[i])
            DFS(g,i);
    }
}
```



## 广度优先搜索

从某个顶点出发,一次性访问所有未被访问的邻接点,再依次从这些访问过的邻接点出发(队列)

算法步骤:

* 初始化图中所有顶点未被访问,初始化一个空队列
* 从图中的某个顶点v出发,访问v并标记已访问,将v入队
* 如果队列非空,则继续执行,否则算法结束
* 队头元素v出队,依次访问v的所有未被访问的邻接点,标记已访问并入队,转向第三步

广度优先搜索走过的路径为广度优先生成树

```cpp
//基于邻接矩阵的广度优先遍历
//#include<queue>
void BFSAM(graph &g,int v)
{
    queue<int> que;		//创建一个队列
    cout<<g.vex[v]<<" ";//访问v
    visited[v]=1;		//标记已访问
    que.push(v);		//入队
    while(!que.empty())	//判断队列是否为空
    {
        int u,w;		//u为队头顶点
        u=que.front();
        que.pop();		//出队,判断队头顶点邻接点
        for(w=0;w<g.vexnum;++w)
        {
            if(g.edge[u][w] && !visited[w])//u与w邻接且w未访问
            {
                cout<<g.vex[w]<<" ";	//访问w
                visited[w]=1;		//标记已访问
                que.push(w);		//入队
            }
        }
    }
}
/*
查找每个邻接点需要O(n)时间,一共n个顶点,总时间复杂度O(n)
使用一共辅助队列,最坏情况下每个顶点入队一次,空间复杂度O(n)
*/
```

```cpp
//基于邻接表的广度优先遍历
void BFSAL(graph &g,int v)
{
    queue<int> que;			//创建一个队列
    cout<<g.vex[v].data<<" ";//访问v
    visited[v]=1;	//标记已访问
    que.push(v);	//入队
    while(!que.empty())//判断队列是否为空
    {
        int u=que.front();
        que.pop();//出队
        listnode *p=g.vex[u].first;//p指向u顶点的第一个邻接点
        while(p!=nullptr)
        {
            int w=p->v;
            if(!visited[w])
            {
                cout<<g.vex[w].data<<" ";
                visited[w]=1;//标记
                que.push(w);//入队
            }
            p=p->next;
        }
    }
}
/*
查找邻接点的时间复杂度为O(e),初始化时间O(n),总时间复杂度O(n+e)
使用一个辅助队列,最坏情况每个顶点入队一次,空间复杂度O(n)
*/
```

```cpp
//非连通图
void BFS(graph &g)
{
    for(int i=0;i<g.vexnum;++i)
    {
        if(!visited[i])
            BFS(g,i);
    }
}
```

# 图的连通性

## 连通分量

无向图中的极大连通子图称为连通分量

* 子图
* 子图是连通的
* 连通子图含有极大顶点数
* 具有极大顶点数的连通子图包含依附于这些顶点的所有边

有向图的极大强连通子图称为有向图的强连通分量

## Tarjan算法

将图看成深度优先生成树,寻找图中的桥和割点

时间戳:`dfn[u]`,表示u结点深度优先遍历的序号

追溯点:`low[u]`,表示u结点或u的子孙能通过非父子边追溯到`dfn`最小的结点序号,即回到最早的过去,若回不去,则`low[u]=dfn[u]`

**无向图桥的判定:**

假设`dfn[5]=5,low[5]=1`,表示5结点可以通过非父子边或子孙结点回到1结点,若5结点的令一个邻接点`dfn[7]=7,low[7]=7`,而`low[7]>dfn[5]` (孩子的`low`值比双亲的`dfn`大),则5--7为桥

```cpp
void tarjan(int u,int fa)//u为出发结点,fa为u的双亲结点
{
    dfn[u]=low[u]=++num;
    for(int i=head[u];i;i=edge[i].next)//访问u的所有邻接点(链式前向星)
    {
        int v=edge[i].to;	//v是u的邻接点
        if(v==fa)			//如果v是u的双亲,continue
            continue;
        if(!dfn[v])			//判断v是否访问过
        {
            tarjan(v,u);	//从v出发深度优先遍历
            low[u]=min(low[u],low[v]);//递归后更新其父结点的low
            if(low[v]>dfn[u])
                cout<<u<<"---"<<v<<"是桥"<<endl;
        }
        else
            low[u]=min(low[u],dfn[v]);//能回到最早的过去
    }
}
```

[tarjan桥](code/graph04.cpp)

**无向图割点的判定:**

x不是根结点,若x为割点,当且仅当搜索树上存在x的一个子节点y满足:`low[y]>=dfn[x]`

x是根结点,若x为割点,当且仅当搜索树上存在至少**两个**子结点满足:`low[y]>=dfn[x]`

```cpp
//与桥判定类似
void tarjan(int u,int fa)
{
    dfn[u]=low[u]=++num;
    int count=0;//记录满足条件结点的个数
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa)
            continue;
        if(!dfn[v])
        {
            taijan(v,u);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u])
            {
                count++;
                if(u!=root || count>1)//root是根结点标号
                    cout<<u<<"是割点"<<endl;
            }
        }
        else
            low[u]=min(low[u],dfn[v]);
    }
}
```

**有向图的强连通分量**

算法步骤:

* 深度优先遍历结点,第一次访问结点x时,将x入栈,且`dfn[x]=low[x]=++num;`
* 遍历x的所有邻接点y
  * 若y没被访问,则递归访问y,返回时更新`low[x]=min(low[x],low[y]);`
  * 若y已被访问且在栈中,则令`low[x]=min(low[x],dfn[y]);`
* x回溯之前,判断如果`low[x]=dfn[x]`,则从栈中不断弹出结点,直到x出栈停止,弹出的结点就是一个连通分量

```cpp
void tarjan(int u)
{
    low[u]=dfn[u]=++num;
    ins[u]=true;//入栈标记为true
    s.push(u);//入栈
    for(int i=head[u];i;i=e[i].next)//访问u发出边邻接点
    {
        int v=e[i].to;
        if(!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(ins[v])
            low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u])
    {
        int v;
        cout<<"连通分量: ";
        do
        {
            v=s.top();
            s.pop();
            cout<<v<<" ";
            ins[v]=false;//出栈标记为false
        }while(v!=u);
        cout<<endl;
    }
}
```

# 图与贪心

## 最短路径

### Dijkstra算法

Dijkstra算法采用的贪心策略是选择特殊路径长度最短的路径,将其连接的`V-S`中的顶点加入集合`S`中,同时更新数组`dist[]`,一旦`S`包含了所有顶点,`dist[]`就是从源到所有其它顶点之间的最短路径长度(`V`是全部顶点的集合,`S`是找到最短路径顶点的集合)

算法步骤:

* 数据结构.设置图的带权邻接矩阵为`G.Edge[][]`,采用一维数组`dist[i]`来记录从源点到`i`顶点的最短路径长度,采用一维数组`p[i]`来记录最短路径上`i`顶点的前驱
* 初始化.令集合`S={u}`,对于集合`V-S`中的所有顶点`x`,初始化`dist[i]=G.Edge[u][i]`,如果源点`u`到顶点`i`右边相连,初始化`p[i]=u`,否则`p[i]=-1`
* 找最小.在集合`V-S`中依照贪心策略寻找使得`dist[j]`具有最小值的顶点`t`,则顶点`t`就是集合`V-S`中距离源点`u`最近的顶点(`O(n)`)
* 加入`S`集合.将顶点`t`加入集合`S`中,同时更新`V-S`
* 判结束.如果`V-S`为空,算法结束,否则转下一步
* 借东风.在第三步中以及找到了源点到`t`的最短路径,那么集合`V-S`中所有与顶点`t`相邻的顶点`j`,都可以借助`t`走捷径.如果`dist[j]>dist[t]+G.Edge[t][j]`,则`dist[j]=dist[t]+G.Edge[t][j]`,记录顶点`j`的前驱为`t`,有`p[j]=t`,转第三步

[Dijkstra](code/graph05.cpp)

### Floyd算法

Floyd算法可以求解任意两个顶点的最短路径,又称为了插点法,其核心算法是在顶点`i`到顶点`j`之间,插入顶点`k`,看是否能缩短`i`和`j`之间距离

算法步骤:

* 数据结构.设置图的带权连接矩阵为`G.Edge[][]`,采用两个辅助数组,最短距离数组`dist[i][j]`,记录从`i`到`j`顶点的最短路径长度,前驱数组`p[i][j]`,记录从`i`到`j`顶点的最短路径上`i`顶点的前驱
* 初始化.初始化`dist[i][j]=G.Edge[i][j]`,如果顶点`i`到顶点`j`有边相连,初始化`p[i][j]=i`,否则`p[i][j]=-1`
* 插点.在`i,j`之间插入顶点`k`,看能否缩短`i`和`j`之间的距离(松弛操作).如果`dist[i][j]>dist[i][k]+dist[k][j]`,则`dist[i][j]=dist[i][k]+dist[k][j]`,记录顶点`j`的前驱为:`p[i][j]=p[k][j]`

[Floyd](code/graph06.cpp)

## 最小生成树

生成树:如果生成子图恰好是一棵树,则称为生成树(e=n-1)

最小生成树:权值之和最小的生成树,则称为最小生成树

稠密图使用prim,稀疏图使用kruskal

### Prim算法

以顶点为集合,将生成树路径上的顶点加入集合

算法步骤:

* 确定合适的数据结构,邻接矩阵`C`,`bool`数组是`s[i]=true`,说明顶点`i`已加入集合`U`,`closest[j]`表示`V-U`中的顶点`j`到集合`U`中的最近邻近点,`lowcost[j]`表示`V-U`中顶点`j`到集合`U`中的最邻近点的边值
* 初始化,令集合`U={u0}`,`u0∈V`,并初始化数组`closest[],lowcost[]和s[]`
* 在`V-U`集合中找`lowcost`值最小值的顶点`t`,即`lowcost[t]=min{lowcost[j] | j∈V-U}`,满足该公式的顶点`t`就是集合`V-U`中连接集合`U`的最邻近点
* 将顶点`t`加入集合`U`
* 如果集合`V-U`为空,算法结束,否则转到下一步
* 对集合`V-U`中的顶点`j`,更新其`lowcost[j]和closest[j]`,从第三步重复

按照上述步骤,最终可以得到一棵权值之和最小的生成树

[Prim](code/graph07.cpp)

### Kurskal算法

以边为集合,将边按权值排序,边两边的顶点进行合并

算法步骤:

* 初始化,将图G的边集数组E中的所有边按权值从小到大排序,初始化边集TE,把每个顶点都初始化为一个孤立的分支
* 在E中寻找权值最小的边`(i,j)`
* 如果顶点`i`和`j`位于两个不同的连通分支,则将边`(i,j)`加入边集TE,并执行合并操作,将两个连通分支进行合并,将`(i,j)`从集合E中删除
* 如果选取边数小于`n-1`,重复第二步,否则,算法结束

[Kurskal](code/graph08.cpp)

两种算法的比较

* kruskal算法每次查找最短的边,prim算法每次加一个顶点,所以稀疏图使用kruskal,稠密图使用prim
* prim时间复杂度度`O(n^2)`,kruskal时间复杂度`O(eloge)`
* kruskal算法需要排序,需要比prim算法更大的空间

## 拓扑排序

一个有向无环图中,用顶点表示活动,用弧表示活动之间的优先关系的有向图,称为AOV网

拓扑排序是指将AOV网中的顶点排成一个线性序列,该序列必须满足:若从顶点`i`到顶点`j`有一条路径,则该序列中顶点`i`一定在顶点`j`之前

基本思想:

* 选择一个无前驱的顶点并输出(入度为0)
* 从图中删除该顶点和该顶点所有的出发边(邻接点入度减1)
* 重复前两步,直到不存在无前驱的顶点
* 如果输出的顶点数小于网中的顶点数,说明网中有环,否则输出的序列为拓扑序列

算法步骤:

* 求各顶点的入度,存入数组`indegree[]`中,并将入度为0的顶点入栈
* 如果栈不为空,栈顶元素`i`出栈,并保存到拓扑序列数组中
* 将顶点`i`的所有邻接点入度减1,如果减1后度为0,则入栈,重复2,3步
* 如果输出的顶点数小于AOV网中的顶点数,则说明网中有环,否则输出拓扑序列