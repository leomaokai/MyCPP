# 动态规划

动态规划也是一种分治思想

动态规划是把原问题分解为若干个子问题,然后自底向上,先求解最小的子问题,把结果存储到表格中,再求解大的子问题,直接从表格中查询小的子问题的解,避免重复计算

使用动态规划的前提条件:

* 最优子结构:
  * 问题的最优解包含其子问题的最优解
* 子问题重叠:
  * 大量的子问题是重叠的,只需求解一次,然后把结果存储在表中,以后使用时可以直接查询,不需要再次求解
* 无后效性:
  * 当前阶段的求解和前面阶段的解有关,和后面阶段的解无关

如何采用动态规划解决问题:

* 分析最优解的结构特征
* 建立最优解的递归式
* 自底向上计算最优解,并记录
* 构造最优解

# 背包问题

背包问题是指在一个有容积或重量限制的背包中放入物品,物品有体积重量价值等属性,要求在满足背包限制的情况下,如何放置物品,使背包中物品的价值之和最大,根据物品限制条件的不同,可分为01背包,完全背包,多重背包和分组背包

## 01背包

给定`n`个物品,每个物品有重量`wi`和价值`vi`,每种物品有且只有一个.背包容量为`w`,要求在不超过背包容量的情况下,如何防止物品,使背包中物品的价值之和最大

假设第`i`阶段表示处理第`i`个物品,第`i-1`阶段表示处理`i-1`个物品,当处理第`i`个物品时,前`i-1`个物品已处理完毕,只需考虑第`i-1`阶段向第`i`阶段转移

用`c[i][j]`表示前`i`件物品放入一个容量为`j`的背包可以获得的最大价值

* 若背包容量小于物品的重量`j<wi`,则不放入,`c[i][j]=c[i-1][j]`
* 若背包容量大于物品的重量`j>=wi`,则考虑放入之前和放入之和哪个价值更大`c[i][j]=max(c[i-1][j],c[i-1][j-wi]+vi)`

```cpp
for(i=1;i<=n;++i)
{
    for(j=1;j<=W;j++)
    {
        if(j<w[i])
    		c[i][j]=c[i-1][j];
    	else
        	c[i][j]=max(c[i-1][j],c[i-1][j-w[i]]+v[i]);  
    }
}
//两层循环嵌套,时间复杂度O(nW)
//使用一个二维数组,空间复杂度O(nW)
```

```cpp
//使用一个维数组倒推求解
for(i=1;i<=n;++i)
    for(j=W;j>=w[i];--j)
        dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
```

## 完全背包

给定`n`个物品,每个物品有重量`wi`和价值`vi`,每种物品的数量没有限制,背包容量`W`,要求在不超过背包容量的情况下,如何放置物品,使背包中物品的价值之和最大

用`c[i][j]`表示前`i`件物品放入一个容量为`j`的背包可以获得的最大价值

* 若背包容量小于物品的重量`j<wi`,则不放入,`c[i][j]=c[i-1][j]`
* 若背包容量大于物品的重量`j>=wi`,则考虑放入之前和放入之和哪个价值更大,因为第`i`件物品可以多次放入,相当于从第`i`阶段向第`i`阶段的转化`c[i][j]=max(c[i][j],c[i][j-wi]+vi)`

也可以用一维数组`dp[j]`,然后采用正向循环,这样保证每个物品可以放入多次

```cpp
for(i=1;i<=n;++i)
    for(i=1;i<=n;++i)
        dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
```

## 多重背包

给定`n`个物品,每个物品有重量`wi`和价值`vi`,每种物品的数量可以大于1但是有限制,第`i`个物品有`ci`个,背包容量为`W`,要求在不超过背包容量的情况下,如何放置物品,使背包中物品的价值之和最大

* 暴力拆分: 把第`i`种物品看作`ci`个独立的物品,每个物品只有一个,转化为01背包问题,容易超时

```cpp
for(int i=1;i<=n;++i)
    for(int k=1;k<=c[i];++k)
        for(int j=W;i>=w[i];--j)
            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
```

* 二进制拆分: 将`ci`个物品拆分成`logci + 1`个物品,若`c[i]*w[i]>=W`,则转换成完全背包

```cpp
for(int i=1;i<=n;++i)
{
    if(c[i]*w[i]>=W)//转换成完全背包
    {
        for(int j=w[i];j<=W;++j)
            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
    }
    else
    {
        for(int k=1;c[i]>0;k<<=1)//二进制拆分
        {
            int x=min(k,c[i]);//x为每次拆分物品的个数
            for(int j=W;i>=w[i]*x;--j)//转换为01背包
                dp[j]=max(dp[j],dp[j-w[i]*x]+x*v[i]);
            c[i]-=x;
        }
    }
}
```

* 数组优化: 用一个`num[j]`数组记录容量为`j`时,放入了多少个第`i`个物品,由此实现数量限制约束

```cpp
for(int i=1;i<=n;++i)
{
    memset(num,0,sizeof(num));
    for(int j=w[i];i<=W;++j)
    {
        if(dp[j]<dp[j-w[i]]+v[i] && num[j-w[i]]<c[i])
        {
            dp[j]=dp[j-w[i]]+v[i];
            num[j]=num[j-w[i]]+1;
        }
    }
}
```

## 分组背包

给定`n`组物品,第`i`组有`ci`个物品,第`i`组第`j`个物品有重量`wij`和价值`vij`,背包容量为`W`,要求在不超过背包容量的情况下,每组至少选择一个物品,如何放置物品,使背包中物品的价值之和最大

因为每组至多选择一个物品,可以将每组看作一个整体,这样就类似于01背包问题

用`c[i][j]`表示前`i`组物品放入一个容量为`j`的背包可以获得大的最大价值,对于第`i`组物品的处理状态:

* 不放入第`i`组物品,装入背包的价值不增加,最大价值为`c[i-1][j]`
* 放入第`i`组的第`k`个物品,相当于从第`i-1`阶段向第`i`阶段转换,即最大价值为`c[i-1][j-wij]+vij`

[分组背包代码](code/code08.cpp)

# 线性DP

具有线性阶段划分的动态规划算法统称为线性动态规划,如果状态包含多个维度,每个维度都是线性变化的阶段,也称为线性DP

## 爬楼梯

有一楼梯共M级,刚开始时在第一级,若每次只能跨上一级或是二级,走到楼上共有多少种走法?

数组`dp[i]`表示上到第`i`级共多少种走法,`dp[i]=dp[i-1]+dp[i-2]  (i>3)`

状态转移方程为斐波那契数列

可使用递归求解(超时),也可使用动态规划求解

[爬楼梯问题](code/code09.cpp)

## 最长子序列

**最长上升子序列**

在给定序列中寻找最长上升子序列的长度

`dp[i]`表示以`a[i]`结尾的最长上升序列长度`a[i]>a[j] , dp[i]=max(dp[i],dp[j]+1)`,求`max(dp[i]`

[最长上升子序列代码](code/code10.cpp)

**最长公共子序列**

给定两个子序列,求最长公共子序列的长度

`dp[i][j]`是`s1`和`s2`的最长公共子序列长度,`dp[i][0]=0,dp[0][j]=0`

```cpp
//状态转移方程
if(s1[i-1]==s2[j-1])
    dp[i][j]=dp[i-1][j-1]+1;
else
    dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
```

[最长公共子序列代码](code/code11.cpp)

# 树形DP

树形DP一般采用深度优先遍历,递归求解每棵子树,回溯时从子节点向上进行状态转移

## 学校舞会

最大独立集:如果选择父结点,则子结点不可以选,每个结点有一个值,求最大和值

状态:

* 对于每一个结点来说,都有选择和不选择两种情况

* `dp[u][0]`表示不选择`u`个结点时的最大和值

* `dp[u][1]`表示选择第`u`个结点时的最大和值

阶段:

* 当前子树的根所在的位置;当子树中的结点处理完毕时,才能进入下一个阶段

状态转移方程:

* 不选择当前结点`u`,那么它的所有结点`v`可选可不选,取最大值即可`dp[u][0]+=max(dp[v][0],dp[v][1])`
* 选择当前结点`u`,那么它的所有子结点`v`均不能选`dp[u][1]+=dp[v][0]`

边界条件:

* `dp[u][0]=0`
* `dp[u][1]=val[u]`

求解目标:

* `max(dp[root][0],dp[root][1])`

[学校舞会最大独立集](code/code12.cpp)