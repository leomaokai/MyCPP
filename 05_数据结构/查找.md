# 顺序查找

线性表查找,无序采用顺序查找,有序采用折半查找

顺序查找:时间复杂度`O(n)`,空间复杂度`O(1)`

```cpp
//算法优化
int sqsearch(int arry[],int n,int x)
{
    int i;
    arry[0]=x;//待查找的元素放入arry[0],作为监视哨
    for(i=n;arry[0]!=x;--i);//不需要判断i是否超出范围
    return i;//当返回0时,说明查找失败
}
```

# 折半查找

序列有序

时间复杂度`O(logn)`

```cpp
//非递归
int binarysearch(int s[],int n,int x)
{
    int low=0;//序列的第一个元素
    int high=n-1;//序列的最后一个元素
    while(low<=high)
    {
        int middle=(low+high)/2;
        if(x==s[middle])
            return middle;
        else if(x>s[middle])
            low=middle+1;
        else
            high=middle-1;
    }
    return -1;
}
```

```cpp
//递归
int binarysearch(int s[],int x,int low,int high)
{
    if(low>high)
        return -1;
    int middle=(low+high)/2;
    if(x==s[middle])
        return middle;
    else if(x<s[middle])
        return binarysearch(s,x,low,middle-1);
    else
        return binarysearch(s,x,middle+1,high);
}
```

# 哈希表

## 散列函数

散列函数,是将关键字映射到存储地址的函数,`hash(key)=addr`

* 散列函数尽可能简单
* 散列函数映射的地址应均匀分布整个地址空间,避免冲突

直接定址法:`hash(key)=a*key+b`

* 适用于事先知道关键字,关键字集合不是很大且连续性较好,关键字如果不连续,则有大量空位,造成空间浪费

除留余数法:`hash(key)=key%p`

* p为不大于表长的最大素数,这样可以避免冲突

随机数法:`hash(key)=rand(key)%p`

* p为不大于表长的最大素数

数字分析法:

* 根据每个数字在各个位上的出现频率,选择均匀分布的若干位,作为散列地址

平方取中法:

* 对关键字平方后,按散列表大小,取中间的若干位作为散列地址,适用于事先不知道关键字且关键字位数不是很大

折叠法:

* 将关键字从左到右分割成位数相等的几部分,将这几个部分叠加求和,取后几位作为散列地址.适用于关键字位数很多,事先不知道关键字的分布

基数转换法:

* 如果关键字为浮点数,可以将关键字转换为整数,如果关键字为字符,可以将字符转换为R进制的整数,然后再使用散列函数

## 冲突处理

无论如何设计散列函数,都无法避免冲突问题

开放地址法:`h1(key)=(h0(key)+di)%m`

* 在线性存储空间上探测其他位置
  * 线性探测,`di=1,2,3,4,...,m-1`,只要有空间,就一定能够探测到位置,但会造成散列地址争夺现象
  * 二次探测,`di=1^2,-1^2,2^2,-2^2,...,k^2,-k^2(k<=m/2)`, 效率较高,但会出现有空间却探测不到的情况
  * 随机探测,`di`为伪随机序列
  * 再散列法

链地址法:

* 如果不同关键字通过散列函数映射到同一地址,则将所有同义词存储在一个线性链表中

建立公共溢出区:

* 发生冲突时,将关键字放入公共溢出区

[hash代码示例](code/search01.cpp)

# 数表查找

## 二叉搜索树

二叉搜索树满足的性质:

* 若左子树非空,则左子树上的所有结点的值均小于根结点的值
* 若右子树非空,则右子树上所有结点的值均大于等于根结点的值
* 其左右子树本身又各是一棵二叉查找树

二叉搜索树的特性:左子树<根<右子树,其中序遍历是一个递增序列

**二叉搜索树的查找:**因为二叉搜索树的中序遍历有序性,所以查找和二分查找类似

* 若二叉查找树非空,将待查找关键字`x`与根结点`T->data`比较
  * 若` x==T->data`,查找成功
  * 若`x < T->data`,则递归查找左子树
  * 若`x > T->data`,则递归查找右子树

```cpp
bool searchbst(bst t,int key)//t为指向根结点的指针
{
    if((!t) && key==t->data)
        return true;	//查找成功返回true
    else if(key< t->data)
        return searchbst(t->lchild,key);//在左子树中查找
    else if(key> t->data)
        return searchbst(t->rchild,key);//在右子树中查找
    else
        return false;	//查找失败
}
```

时间复杂度与树的形态有关

* 最好情况下,树的形态和二分查找的判定树相似,每次查找可以缩小一半的搜索范围,`O(logn)`
* 最坏情况下,树的形态为单支树,退化为顺序查找,`O(n)`
* 平均情况下,`O(n)`

空间复杂度为`O(1)`

**二叉搜索树的插入:**

* 若树为空,则创建新结点
* 若树非空,将待插入关键字`x`与根结点`T->data`比较
  * 若`x < T->data`,则将`x`插入到左子树
  * 若`x > T->data`,则将`x`插入到右子树

```cpp
void insertbst(bst &t,int e)
{
    if(!t)
    {
        bst temp=new bstnode();//生成新结点
        temp->data=e;
        temp->lhcild=temp->rchild=nullptr;
        t=temp;
    }
    else if(e < t->data)
        insertbst(t->lchild,e);//插入左子树
    else if(e > t->data)
        insertbst(t->rchild,e);//插入右子树
}
```

二叉搜索树插入前需要先查找插入位置,插入本身只需要常数时间,但查找插入位置的时间复杂度为`O(logn)`

**二叉搜索树的创建:**

二叉搜索树的创建从空树开始,按照输入关键字的顺序依次进行插入操作

* 初始化二叉搜索树为空树`T`
* 输入一个关键字`x`,将`x`插入到`T`中
* 重复第二步

```cpp
void createbst(bst &t)
{
    t=nullptr;
    int e=0;
    for(int i=0;i<maxn;++i)
    {
        cin>>e;
        insertbst(t,e);
    }
}
```

时间复杂度:

最好`O(nlogn)`

最坏`O(n^2)`

**二叉搜索树的删除:**

首先在二叉搜索树中找到要删除的结点,然后执行删除操作

* 若被删除结点左子树(右子树)为空,则令其右子树(左子树)代替其位置即可
* 若被删除结点左右子树均不空,根据二叉搜索树的中序有序性,删除该结点,可以用其直接前驱(或直接后继)代替其位置,然后删除其直接前驱(直接后继)
  * 直接前驱:中序遍历中,结点`p`的直接前驱为其左子树的最右结点(没有右子树)
  * 直接后继:中序遍历中,结点`p`的直接后继为其右子树的最左结点(没有左子树)

二叉搜索树的删除,主要是查找的过程,需要`O(logn)`时间,删除的过程,需要找前驱或后驱,也需要`O(logn)`时间,所以时间复杂度为`O(logn)`

[二叉搜索树代码示例](code/search02.cpp)

## 平衡二叉树

平衡二叉树(`AVL`)的性质:

* 左右子树高度差的绝对值不超过1
* 左右子树也是平衡二叉树

结点左右子树的高度之差称为平衡因子,二叉搜索树中,每个结点的平衡因子绝对值不超过1即为平衡二叉树

平衡二叉树的局部性:

* 单次插入或删除后,至多有`O(1)`处出现不平衡
* 总可以在`O(logn)`时间内,使这`O(1)`处不平衡重新调整为平衡

调平衡的方法:

* LL型:不平衡结点到新结点的路径前两个都是左子树L,需要进行LL旋转(顺时针)调整平衡
* RR型:不平衡结点到新结点的路径前两个都是右子树R,需要进行RR旋转(逆时针)调整平衡
* LR型:不平衡结点到新结点的路径前两个依次是左子树L,右子树R,将LR旋转成LL
* RL型:不平衡结点到新结点的路径前两个依次是右子树R,左子树L,将RL旋转成RR

平衡二叉树的插入:在平衡二叉树上插入新的数据元素x,首先查找其插入位置,查找过程中,用`p`指针记录当前结点,`f`指针记录`p`的双亲

* 先在二叉树中查找`x`,如果查找成功,什么也不做,返回`p`,如果查找失败,则执行插入操作
* 创建一个新结点`p`存储`x`,该结点的双亲为`f`,高度为1
* 从新结点的双亲`f`出发,向上寻找最近的不平衡结点,逐层检查各代双亲结点,如果平衡,则更新其高度,继续向上寻找;如果不平衡,则判断平衡类型,并作相应的调整,返回`p`

平衡二叉树的创建:平衡二叉树的创建和二叉搜索树的创建类似,只是插入操作多了调平衡

平衡二叉树的删除:删除操作需要一直从删除结点的双亲向上检查,发现不平衡立即调整,然后继续向上检查,检查到树根为止

[平衡二叉树代码示例](code/search03.cpp)

