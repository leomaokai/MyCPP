# virtual

通过虚函数可实现运行时的多态

* 构造函数不能是虚函数
* 析构函数应当是虚函数
* 友元不能是虚函数
* 静态函数不能是虚函数

# vtbl

通常编译器处理虚函数的方法是:给每个对象添加一个隐藏成员.隐藏成员中保存了一个指向函数地址数组的指针.这种数组称为虚函数表.

虚函数表中存储了为类对象进行声明的虚函数的地址.

调用虚函数时,程序将查看存储在对象中的`vtbl`地址,然后转向相应的函数地址表.

使用虚函数时,在内存和执行速度方面有一定的成本,虽然非虚函数的效率比虚函数稍高,但不具备运行时多态

# 虚析构函数

当我们需要删除一个指向派生类的基类指针时,我们希望销毁整个对象,包括派生类和基类,而不仅仅是基类,这就需要将基类的析构函数声明为虚函数.

```c++
//virtual_1.cpp
#include<iostream>
using namespace std;;
class person
{
    public:
    virtual ~person()
    {
        cout<<"~person"<<endl;
    }
};
class stu : public person 
{
    public:
    ~stu()
    {
        cout<<"~stu"<<endl;
    }
};
int main()
{
    person* ptr = new stu;
    delete ptr;
    return 0;
} 
```

```
~stu
~person
```

如果person类的析构函数没有声明为虚函数,那么仅仅会`~person`

事实上,只要一个类可能会被其它类所继承,就应该声明虚析构函数

# 抽象类

纯虚函数:没有函数体的虚函数

抽象类:包含纯虚函数的类

抽象类只能作为基类,不能创建对象.

