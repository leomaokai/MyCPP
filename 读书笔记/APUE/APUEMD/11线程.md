# 线程概念
典型的UNIX进程可以看成只有一个控制线程：一个进程在某时刻只能做一件事情。有了多个控制线程以后，在程序设计时就可以把进程设计成在某一时刻能做不止一件事，每个线程处理各自独立的任务。这种方法有很多好处：
* 通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编成模式，同步编成模式要比异步编程模式简单得多。
* 多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件描述符。
* 有些问题可以分解从而提高整个程序的吞吐量。在只有一个控制线程的情况下，一个单线程进程要完成多个任务，只需要把这些任务串行化。但有多个控制线程时，相互独立的任务的处理就可以交叉进行，此时只需要为每个任务分配一个单独的线程。当然只有在两个任务的处理过程互不依赖的情况下，两个任务才可以交叉执行。
* 交互的程序同样可以通过使用多线程来改善响应时间，多线程可以把程序中处理用户输入输出的部分与其他部分分开。
处理器的数量并不影响程序结构，所以不管处理器的个数多少，程序都可以通过使用线程得以简化。
每个线程都包含有表示执行环境所必需的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。
一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。
# 线程标识
就像每个进程有一个进程ID一样，每个线程也有一个线程ID。进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有在它所属的进程上下文中才有意义。
使用函数pthread_equal对两个线程ID进行比较
线程可以调用pthread_salf函数获得自身的线程ID
当线程需要识别以线程ID作为标识的数据结构时，pthread_self函数可以与pthread_equal一起使用。例如，主线程可能把工作任务放到一个队列中，用线程ID来控制每个工作线程处理哪些作业。
# 线程创建
新的线程可以通过调用pthread_create函数创建
```c
#include<pthread.h>
int pthread_create(pthread_t *restrict tidp,
					const pthread_attr_t *restrict attr,
					void *(*start_rtn)(void *),void *restrict arg);
```
返回值：若成功，返回0，否则，返回错误编号
当pthread_create成功返回时，新创建线程的线程ID会被设置成tidp指向的内存单元。attr参数用于定制各种不同的线程属性。
新创建的线程从start_rtn函数的地址开始运行，该函数只有一个无类型指针参数arg。
线程创建时并不能保证哪个线程会先运行：是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。
# 线程终止
如果进程中的任意线程调用了`exit`、`_Exit`或者`_exit`，那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程。
单个线程可以通过3种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流。
* 线程可以简单地从启动例程中返回，返回值是线程的退出码
* 线程可以被同一进程中的其他线程取消
* 线程调用pthread_exit
当一个线程通过调用`pthread_exit`退出或者简单地从启动例程中返回时，进程中的其他线程可以通过调用`pthread_join`函数获得该线程的退出状态。
线程可以通过调用`pthread_cancel`函数来请求取消同一进程中的其他线程。
# 线程同步
当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性问题。同样，如果变量是只读的，多个线程同步读取该变量也不会有一致性问题。但是，当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就需要对这些线程进行同步，确保他们在访问变量的存储内容时不会访问到无效的值。
当一个线程修改变量时，其他线程在读取这个变量时可能会看到一个不一致的值。在变量修改时间多于一个存储器访问周期的存储器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。当然，这种行为是与处理器体系结构相关的，但是可移植的程序并不能对使用何种处理器体系结构做出任何假设。
为了解决不一致的问题，线程不得不使用锁，同一时间只允许一个线程访问该变量。
两个或多个线程试图同一时间修改同一变量时，也需要进行同步。增加操作通常分解为以下3步：
* 从内存单元读入寄存器
* 在寄存器中对变量做增量操作
* 把新的值写回内存单元
如果两个线程试图几乎同一时间对同一个变量做增量操作而不进行同步的话，结果就可能出现不一致，变量可能比原来增加了1，也可能比原来增加了2，具体增加了1还是2要取决于第二个线程开始操作时获取的数值。
如果修改操作是原子操作，那么就不存在竞争。
除了计算机体系结构以外，程序使用变量的方式也会引起竞争，也会导致不一致的情况发生。
# 互斥量
可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。
互斥量本质上是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量。
对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁的，只能回去再次等待他重新变为可用。在这种方式下，每次只有一个线程可以向前执行。
只有将所有线程都设计成遵守相同数据访问规则的，互斥机制才能正常工作。操作系统并不会为我们做数据访问的串行化。如果允许其中某个线程在没有得到锁的情况下也可以访问共享资源，那么即使其他的线程在使用共享资源前都申请了锁，也还是会出现数据不一致的问题。
在使用互斥量以前，必须的首先对他进行初始化，可以通过调用`pthread_mutex_init`函数进行初始化。如果动态分配互斥量，在释放内存前需要调用`pthread_mutex_destroy`。
对互斥量进行加锁，需要调用`pthread_mutex_lock`。如果互斥量已经上锁，调用线程将阻塞直到互斥量被解锁。对互斥量解锁，需要调用`pthread_mutex_unlock`。
如果线程不希望被阻塞，他可用使用`pthread_mutex_trylock`尝试对互斥量进行加锁。如果调用此函数时互斥量处于未锁住状态，那么该函数将锁住互斥量，不会出现阻塞直接返回0，否则`pthread_mutex_trylock`就会失败，不能锁住互斥量，返回EBUSY。
# 避免死锁
如果线程试图对同一个互斥量加锁两次，那么它自身就会陷入死锁状态，但是使用互斥量还有其他不太明显的方式也能产生死锁。例如：
程序中使用一个以上的互斥量时，如果允许一个线程一直占有第一个互斥量，并且在试图锁住第二个互斥量时处于阻塞状态，但是拥有第二个互斥量的线程也在试图锁住第一个互斥量。因为两个线程都在相互请求另一个线程拥有的资源，所以这两个线程都无法向前运行，于是将产生死锁。
可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。例如，假设需要两个互斥量A和B同时加锁，如果所有线程总是在对互斥量B加锁之前锁住互斥量A，那么使用这两个互斥量就不会产生死锁。可能出现的死锁只会发生在一个线程试图锁住另一个线程以相反的顺序锁住的互斥量。
有时候，应用程序的结构使得对互斥量进行排序是很困难的。如果涉及来太多的锁和数据结构，可用的函数并不能把他转换成简单的层次，那么就需要采用另外的方法。在这种情况下，可以先释放占有的锁，然后过一段时间再试。
# 函数`pthread_mutex_timedlock`
当线程试图获取一个已加锁的互斥量时，`pthread_mutex_timedlock`互斥量原语允许绑定线程阻塞时间。`pthread_mutex_timedlock`函数与`pthread_mudex_lock`是基本等价的，但是达到超时时间值时，`pthread_mutex_timedlock`不会对互斥量进行加锁，而是返回错误码ETIMEDOUT。
超时指定愿意等待的绝对时间。这个超时时间是用timespace结构来表示的，他用秒和纳秒来描述时间。
# 读写锁
读写锁与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。
读写锁可以有3种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。
当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放他们的读锁为止。虽然各操作系统对读写锁的实现各不相同，但当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足。
读写锁非常适合于对数据结构读的次数远大于写的情况。当读写锁在写模式时，他所保护的数据结构就可以被安全地修改，因为一次只有一个线程可以在写模式下拥有这个锁。当读写锁在读模式下时，只要线程先获取来读模式下的读写锁，该锁所保护的数据结构就可以被多个获得读模式锁的线程读取。
读写锁也叫共享互斥锁。当读写锁是读模式时，就可以说成是以共享模式锁住的。当他是写模式锁住的时候，就可以说成是以互斥模式锁住的。
与互斥量相比，读写锁在使用之前必须初始化，在释放它们底层的内存之前必须销毁。
# 条件变量
条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。
条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种变化，因为互斥量必须在锁定以后才能计算条件。
# 自旋锁
自旋锁与互斥量类似，但他不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等阻塞状态。自旋锁可用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。。
自旋锁通常作为底层原语用于实现其他类型的锁。根据他们所基于的系统体系结构，可以通过使用测试并设置指令有效地实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其他的事情。这也是自旋锁只能够被持有一小段时间的原因。
当自旋锁用在非抢占式内核中时是非常有用的：除了提供互斥机制以外，他们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态，因为他需要获取已被加锁的自旋锁（把中断想成是另一种抢占）。在这种类型的内核中，中断处理了程序不能休眠，因此他们能用的同步原语只能是自旋锁。
但是在用户层，自旋锁并不是非常有用的，除非运行在不允许抢占的实时调度类中。
很多互斥量的实现非常高效，以至于应用程序采用互斥锁的性能与曾经采用过自旋锁的性能基本是相同的。事实上，有些互斥量的实现在试图获取互斥量的时候会自旋一小段时间，只是在自旋计数到达某一阀值的时候才会休眠。这些因素，加上现代处理器的进步，使得上下文切换越来越快，也使得自旋锁只在某些特定的情况下有用。
# 屏障
屏障是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。

