# 进程标识

每个进程都有一个非负整型表示唯一进程ID.因为进程ID标识符总是唯一的,常将其用作其他标识符的一部分以保证其唯一性.例如,应用进程有时就把进程ID作为名字的一部分来创建一个唯一的文件名

虽然是唯一的,但是进程ID是可复用的.当一个进程终止后,其进程ID就成为复用的候选者.

系统中有一些专用进程,但具体细节随实现而不同.

ID为0的进程通常是调度进程,常常被称为交换进程.该进程是内核的一部分,它并不执行任何磁盘上的程序,因此也被称为系统进程.

ID为1通常是`init`进程,在自举过程结束时由内核调用.此进程负责在自举内核后启动一个UNIX系统.init通常读取与系统有关的初始文件,并将系统引导到一个状态.init进程绝不会终止.它是一个普通的用户进程,但是它以超级用户特权运行.

进程ID2是页守护进程,此进程负责支持虚拟存储器系统的分页操作

除进程ID,每个进程还有一些其它标识

```c
#include<unistd.h>
pid_t getpid(void);//调用进程ID 
pid_t getppid(void);//调用进程的父进程ID
uid_t getuid(void);//调用进程的实际用户ID
uid_t geteuid(void);//调用进程的有效用户ID
gid_t getgid(void);//调用进程的实际组ID
gid_t getegid(void);//调用进程的有效组ID
```

# 函数fork

一个现有的进程可以调用fork函数创建一个新进程

```c
#include<unistd.h>
pid_t fork(void);
//返回值:子进程返回0,父进程返回子进程ID,若出错,返回-1
```

由fork创建的新进程称为子进程.fork函数被调用一次,但返回两次.两次返回的区别是子进程返回值是0,而父进程返回值则是新建子进程的进程ID

将子进程ID返回给父进程的理由:因为一个进程的子进程可以是多个,并且没有一个函数使一个进程可以获得其所有子进程的的进程ID.

fork使子进程返回值0的理由:一个进程只会有一个父进程,所以子进程总是可以调用getppid以获得其父进程的进程ID

子进程和父进程继续执行fork调用之后的指令.子进程是父进程的副本.例如,子进程获得父进程数据空间,堆和栈的副本.注意,这是子进程所拥有的副本,父进程和子进程并不共享这些存储空间部分.父进程和子进程共享正文端

由于fork之后经常跟随着exec,所以现在很多现实并不执行一个父进程数据段,堆和栈的完全副本.作为替代,使用了写时复制技术.这些区域由父进程和子进程共享,而且内核将它们的访问权限改变为只读.如果父进程和子进程中的任意一个试图修改这些区域,则内核只为修改区域的那块内存制作一个副本,通常是虚拟存储系统中的一页

# 函数vfork
vfork函数的调用序列和返回值与fork相同，但两者的语义不同
vfork函数用于创建一个新进程，而该新进程的目的是执行一个新进程。vfork与fork一样都创建一个子进程，但是它并不将父进程的地址地址空间完全复制到子进程中，因为子进程会立即调用`exec`或`exit`，于是也就不会引用该地址空间。
vfork于fork之间的另一个区别是：vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中任意一个时，父进程会恢复运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。
# 函数exit
进程有5种正常终止和3种异常终止。
不管进程如何终止，最后都会执行内核中的同一段代码，这段代为相应进程关闭所有打开描述符，释放它所使用的存储器等。
对于上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3种终止函数（exit、_exit和_ _Exit），实现这一点的方法是，将其推出状态作为参数传送给函数。在异常终止情况下，内核产生一个指示其终止原因的终止状态。在任意一种情况下，该终止进程的父进程都能用wait或waitpid函数取得其终止状态。
# 函数wait和waitpid
当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是异步事件，所以这种信号也是内核向父进程发送的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数（信号处理程序）。
调用wait或waitpid的进程可能会发生什么：
* 如果其所有进程都还在运行，则阻塞
* 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回
* 如果它没有任何子进程，则立即出错返回
如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。但是如果在随机时间点调用wait，则进程可能会阻塞。
```c
#include<sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid,int *statloc,int options);
```
返回值：若成功，返回进程ID，若出错，返回0或-1
这两个函数的区别如下：
* 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞
* waitpid并不等待其调用之后的第一个终止子进程，它有若干个选项。可以控制它所等待的进程
如果子进程已经终止，并且是一个僵死进程，则wait立即返回并取得该子进程的状态；否则wait使其调用者阻塞，直到一个子进程终止。如果调用者阻塞而且它有多个子进程，则在其某个子进程终止时，wait就立即返回。因为wait返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了。
这两个函数参数statloc是一个整型指针。如果其不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将该参数指定为空指针。
waitpid函数提供了wait函数没有提供的3个功能：
* waitpid可等待一个特定进程，而wait则返回任一终止子进程的状态。
* waitpid提供了一个wait的非阻塞版本。有时希望获取一个子进程的状态，但是不想阻塞
* waitpid通过WUNTRACED和WCONTINUED选项支持作业控制
# 函数waitid
此函数类似于waitpid，但提供了更多的灵活性
```c
#include<sys/wait.h>
int waitid(idtype_t idtype,id_t id,siginfo_t *infop,int options):
```
返回值：若成功，返回0，若失败，返回-1
与waitpid相似，waitid允许一个进程指定要等等的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型。而不是将此与进程ID或进程组ID组合成一个参数。ID参数的作用与idtype的值相关。
|常量|说明|
|P_PID|等待一特定进程：id包含要等待子进程的进程ID|
|P_PGID|等待一特定进程组中任一子进程：id包含要等待子进程的进程组ID|
|P_ALL|等待任一子进程：忽略id|
# 函数wait3和wait4
这两个函数是从UNIX系统的BSD分支沿袭下来的，它们的功能比POSIX.1函数wait、waitpid和waitid所提供功能要多一个，这与附加参数有关。该参数允许内核返回又终止进程及其所有子进程使用的资源概括。
资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。
# 竞争条件
当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件。如果fork之后的某种逻辑显式或隐式地依赖于在fork之后是子进程先运行还是父进程先运行，那么fork函数就会是竞争条件活跃的滋生地。通常我们不能预料哪一个进程先运行。即使我们知道哪一个进程先运行，在该进程开始运行后所发生的事情也依赖于系统以及内核的调度算法。
# 函数exec
用fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后进程的ID并未改变。exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。
有7种不同的exec函数可供使用，它们常常被统称为exec函数，我们可以使用这7个函数中的任一个。这些exec函数使得UNIX系统进程控制原语更加完善。用fork可以创建新进程，用exec可以初始执行新的程序。exit和wait函数处理终止和等待终止。这些是我们需要的基本进程控制原语。
# 更改用户ID和更改组ID
在unix系统中，特权以及访问控制是基于用户ID和组ID的。当程序需要增加特权或访问当前并不允许访问的资源时，我们需要更换自己的用户ID和组ID，使得新ID具有合适的特权或访问权限。
一般而言，在设计应用时，我们总试图使用最小特权模型。依照次模型，我们的程序应当只具有为完成给定任务所需的最小特权。者降低了由恶意用户试图哄骗我们的程序以未预测的方式使用特权造成的安全性风险。
可以用setuid函数设置实际用户ID和有效用户ID，可以用setgid函数设置实际组ID和有效组ID。
```c
#include<unistd.h>
int setuid(uid_t uid);
int setgid(gid_t gid);
```
更改用户ID的规则：
* 若进程具有超级用户特权，则setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为uid
* 若进程没有超级用户特权，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid，不更改实际用户ID和保存的设置用户ID
* 如果上面两个条件都不满足，则errno设置为EPERM，并返回-1
POIX.1包含了两个函数seteuid和setegid。它们类似于setuid和setgid，但只改变有效用户ID和有效组ID。
# 函数system
ISO C定义了system函数，但是其操作对系统的依赖性很强。
```c
#include<stdlib.h>
int system(const char *cmdstring);
```
如果cmdstring是一个空指针，则仅当命令处理程序可用时，system返回非0值，这一特性可以确定在一个给定的操作系统上是否支持system函数。在UNIX中，system总是可用的。
因为system在其现实中调用了fork、exec和waitpid，因此有3种返回值。
* fork失败或者waitpid返回除EINTR之外的出错，则system返回-1，并且设置errno以指示错误类型
* 如果exec失败，则其返回值如同shell执行了exit一样
* 所有3个函数都成功，那么system的返回值是shell的终止状态
使用system而不是直接使用fork和exec的优点是：system进行了所需的各种出错处理以及各种信号处理。
# 进程会计
大多数UNIX系统提供了一个选项以进行进程会计处理。启用该选项后，每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据，一般包括命令名、所使用的CPU时间总量、用户ID和组ID、启动时间等。
# 进程调调
UNIX系统历史上对进程对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是由内核确定的。进程可以通过调整友好值选择以更低优先级运行。只有特权进程允许提高调度权限。
进程可以通过调用nice函数获取或更改它的友好值。使用这个函数，进程只能影响自己的友好值，不能影响其他进程的友好值。
getpriority函数可以像nice函数那样用于获取进程的友好值，但是getpriority还可以获取一组相关进程的友好值。
setpriority函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级。
# 进程时间
我们可以度量3个时间：墙上时钟时间、用户CPU时间和系统CPU时间。任一进程都可调用times函数获取它自己以及已终止子进程的上述值。